{"version":3,"file":"main.js","mappings":"uCAAA,MAAMA,EAAUC,EAAQ,KAClBC,EAAQD,EAAQ,KAChBE,EAAeF,EAAQ,KAEvBG,EAAkBH,EAAQ,KAEhC,SAASI,EAASC,GAKdC,KAAKD,SAAWA,EAEhBC,KAAKC,QAAU,IAAIC,MACnBF,KAAKC,QAAQE,IAAM,8BAEnBH,KAAKI,KAAO,IAAIF,MAChBF,KAAKI,KAAKD,IAAM,qBAEhBH,KAAKK,IAAM,IAAIH,MACfF,KAAKK,IAAIF,IAAM,oBAYfH,KAAKM,MAAQ,CACT,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACvC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACv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","sources":["webpack://cake-man-near-you/./src/scripts/TileMap.js","webpack://cake-man-near-you/./src/scripts/cakeman.js","webpack://cake-man-near-you/./src/scripts/game.js","webpack://cake-man-near-you/./src/scripts/ghost.js","webpack://cake-man-near-you/./src/scripts/movingDirections.js","webpack://cake-man-near-you/./src/scripts/polyTreeNode.js","webpack://cake-man-near-you/./src/scripts/utils.js","webpack://cake-man-near-you/webpack/bootstrap","webpack://cake-man-near-you/./src/index.js"],"sourcesContent":["const Cakeman = require(\"./cakeman.js\");\nconst Ghost = require(\"./ghost.js\");\nconst PolyTreeNode = require(\"./polyTreeNode.js\");\n\nconst MovingDirection = require(\"./movingDirections.js\");\n\nfunction TileMap (tileSize) {\n\n    // I used MDN Web Documents Square TileMaps Statis Implementation. \n    // https://developer.mozilla.org/en-US/docs/Games/Techniques/Tilemaps/Square_tilemaps_implementation:_Static_maps\n\n    this.tileSize = tileSize\n\n    this.cakeman = new Image();\n    this.cakeman.src = \"../images/cakemanClosed.png\";\n\n    this.wall = new Image();\n    this.wall.src = \"../images/wall.png\";\n\n    this.dot = new Image();\n    this.dot.src = \"../images/dot.png\";\n\n    // 1 wall\n    // 0 dots\n    // 2 empty black\n    // 7 cakeman\n    // 3 ghost red\n    // 4 ghost blue\n    // 5 ghost purple\n    // 6 ghost pink\n    // 8 score\n    \n    this.tiles = [        \n        [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9],\n        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n        [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],\n        [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],\n        [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],\n        [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],\n        [1,0,0,0,4,0,0,0,0,0,0,0,0,0,0,3,0,0,0,1],\n        [1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,1],\n        [1,0,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,1],\n        [1,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,1],\n        [1,1,1,1,0,1,2,2,2,2,2,2,2,2,1,0,1,1,1,1],\n        [1,1,1,1,0,1,2,1,1,1,1,1,1,2,1,0,1,1,1,1],\n        [2,2,7,2,0,2,2,1,1,1,1,1,1,2,2,0,2,2,2,2],\n        [1,1,1,1,0,1,2,1,1,1,1,1,1,2,1,0,1,1,1,1],\n        [1,1,1,1,0,1,2,2,2,2,2,2,2,2,1,0,1,1,1,1],\n        [1,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,1],\n        [1,0,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,1],\n        [1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,1],\n        [1,0,0,0,6,0,0,0,0,0,0,0,0,0,0,5,0,0,0,1],\n        [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],\n        [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],\n        [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],\n        [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],\n        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n    ];\n\n    this.ghostNode = null;\n}\n\nTileMap.prototype.setCanvas = function setCanvas(canvas) {\n    canvas.width = this.tiles[0].length * this.tileSize;\n    canvas.height = this.tiles.length * this.tileSize;\n}\n\nTileMap.prototype.draw = function(ctx, cakeman, isLost, isWin) {\n    for(let row=0; row<this.tiles.length; row++) {\n        for(let column=0; column<this.tiles[row].length; column++) {\n            let tile = this.tiles[row][column];\n            if(tile === 1) this.drawWall(ctx, column, row, this.tileSize);\n            else if(tile === 0) this.drawDot(ctx, column, row, this.tileSize);\n            else if(tile === 2){\n                this.drawEmpty(ctx, column, row, this.tileSize);\n            }\n\n            // ctx.strokeStyle = \"yellow\";\n            // ctx.strokeRect(\n            //     column*this.tileSize,\n            //     row * this.tileSize,\n            //     this.tileSize,\n            //     this.tileSize\n            // )\n        }\n    }\n    // ctx.strokeStyle = \"red\";\n    // ctx.strokeRect(\n    //     0,\n    //     0,\n    //     144,\n    //     24\n    // )\n    ctx.clearRect(0, 0, 480, 24);\n\n    ctx.font = '16px Comic Sans MS';\n    ctx.fillStyle = 'white';\n    // console.log(cakeman.score);\n    ctx.fillText(`Score: ${cakeman.score}`, 30, 18);\n    ctx.fillText(`Countdown: ${cakeman.timeLeft}`, 360, 18);\n\n    // if(isLost) {\n    //     console.log(isLost);\n    //     // this.gameOverScreen(ctx, cakeman);\n    //     ctx.font = '20px Comic Sans MS';\n    //     ctx.fillStyle = 'white';\n    //     ctx.fillText('Game Over', 185, 296);\n    //     ctx.fillText(`Score: ${cakeman.score}`, 196, 320);\n    // }\n\n    // if(isWin) {\n    //     this.winScreen(ctx, cakeman);\n    // }\n    // ctx.clearRect(180, 275, 110, 50)\n    // ctx.font = '20px Comic Sans MS';\n    // ctx.fillStyle = 'white';\n    // ctx.fillText('Game Over', 185, 296);\n    // ctx.fillText('Score: ', 196, 320)\n}\n\nTileMap.prototype.drawDot = function(ctx, column, row, size) {\n    ctx.drawImage(\n        this.dot, \n        column * this.tileSize,\n        row * this.tileSize,\n        size,\n        size\n    );\n};\n\nTileMap.prototype.drawWall = function(ctx, column, row, size) {\n    ctx.drawImage(\n        this.wall, \n        column * this.tileSize,\n        row * this.tileSize,\n        size,\n        size\n    );\n};\n\nTileMap.prototype.drawEmpty = function(ctx, column, row, size) {\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(column * this.tileSize, row*this.tileSize, size, size);\n}\n\nTileMap.prototype.getCakeman = function() {\n    for(let row=0; row<this.tiles.length; row++) {\n        for(let column=0; column<this.tiles[row].length; column++) {\n            let tile = this.tiles[row][column];\n            if(tile === 7) {\n                this.tiles[row][column] = 0;\n                let cakeMan = new Cakeman({\n                    position: [column*this.tileSize, row*this.tileSize],\n                    size: this.tileSize,\n                    tileMap: this\n                    }\n                );\n                return cakeMan;\n            }\n        }\n    }\n}\n\nTileMap.prototype.getGhost = function() {\n    for(let row=0; row<this.tiles.length; row++) {\n        for(let column=0; column<this.tiles[row].length; column++) {\n            let tile = this.tiles[row][column];\n            if(tile === 3) {\n                this.tiles[row][column] = 0;\n                let ghost = new Ghost({\n                    position: [column*this.tileSize, row*this.tileSize],\n                    size: this.tileSize,\n                    tileMap: this,\n                    id: 3\n                    }\n                );\n                this.ghostNode = new PolyTreeNode({position: [row, column]});\n                return ghost;    \n            } else if(tile === 4) {\n                this.tiles[row][column] = 0;\n                let ghost = new Ghost({\n                    position: [column*this.tileSize, row*this.tileSize],\n                    size: this.tileSize,\n                    tileMap: this,\n                    id: 4\n                    }\n                );\n            return ghost;\n            } else if(tile === 5) {\n                this.tiles[row][column] = 0;\n                let ghost = new Ghost({\n                    position: [column*this.tileSize, row*this.tileSize],\n                    size: this.tileSize,\n                    tileMap: this,\n                    id: 5\n                    }\n                );\n            return ghost;\n            } else if(tile === 6) {\n                this.tiles[row][column] = 0;\n                let ghost = new Ghost({\n                    position: [column*this.tileSize, row*this.tileSize],\n                    size: this.tileSize,\n                    tileMap: this,\n                    id: 6\n                    }\n                );\n            return ghost;\n            } \n        }\n    }\n}\n\nTileMap.prototype.didCollidedWithEnv = function(x, y, direction) {\n    if(typeof direction === null) return;\n    if(Number.isInteger(x/this.tileSize) && Number.isInteger(y/this.tileSize)) {\n        let column = 0;\n        let row = 0;\n        let nextColumn = 0;\n        let nextRow = 0;\n\n        switch(direction) {\n            case MovingDirection.right:\n                nextColumn = x + this.tileSize;\n                column = nextColumn / this.tileSize;\n                row = y / this.tileSize;\n                break;\n            case MovingDirection.left:\n                nextColumn = x - this.tileSize;\n                column = nextColumn / this.tileSize;\n                row = y / this.tileSize;\n                break;\n\n            case MovingDirection.up:\n                nextRow = y - this.tileSize;\n                row = nextRow / this.tileSize;\n                column = x / this.tileSize;\n                break;\n            case MovingDirection.down:\n                nextRow = y + this.tileSize;\n                row = nextRow / this.tileSize;\n                column = x / this.tileSize;\n                break;\n        }\n        const tile = this.tiles[row][column];\n        if(tile === 1) return true;\n    }\n    return false;\n}\n\nTileMap.prototype.removeDot = function removeDot(x, y) {\n    const row = y / this.tileSize;\n    const column = x / this.tileSize;\n\n    if(Number.isInteger(row) && Number.isInteger(column)) {\n        if(this.tiles[row][column] === 0) {\n            this.tiles[row][column] = 2;\n            return true;\n        }\n    }\n    return false; \n}\n\nTileMap.prototype.buildTree = function buildTree(ghost, cakeman) {\n    \n    let ghostX = Math.floor(ghost.x/24);\n    let ghostY = Math.floor(ghost.y/24);\n    let inputGhostNode = new PolyTreeNode({position: [ghostX, ghostY]});\n    let cakemanX = cakeman.x;\n    let cakemanY = cakeman.y;\n\n    let queue = []\n    queue.push(inputGhostNode);\n\n    let isFound = false;\n    let visitedNodes = [];\n\n    while(queue.length && !isFound) {\n\n        let currentNode = queue.shift();\n\n        let x = currentNode.x;\n        let y = currentNode.y;\n        console.log(`x: ${x} vs y: ${y}`);\n        // return;\n        \n        if(this.tiles[x+1][y] !== 1) {\n            let child = new PolyTreeNode({position: [x+1, y]});\n            if(!visitedNodes.includes(child)) {\n                queue.push(child);\n                visitedNodes.push(child);\n                currentNode.addChild(child);\n                child.assignParent(currentNode);\n                if((x+1) === cakemanX && y === cakemanY) {\n                    isFound = true;\n                    break;\n                }\n            }\n        }if(this.tiles[x][y+1] !== 1) {\n            let child = new PolyTreeNode({position: [x, y+1]});\n            if(!visitedNodes.includes(child)) {\n                queue.push(child);\n                visitedNodes.push(child);\n                currentNode.addChild(child);\n                child.assignParent(currentNode);\n                if((x) === cakemanX && (y+1) === cakemanY) {\n                    isFound = true;\n                    break;\n                }\n            }\n        }if (this.tiles[x-1][y] !== 1) {\n            let child = new PolyTreeNode({position: [x-1, y]});\n            if(!visitedNodes.includes(child)) {\n                queue.push(child);\n                visitedNodes.push(child);\n                currentNode.addChild(child);\n                child.assignParent(currentNode);\n                if((x-1) === cakemanX && y === cakemanY) {\n                    isFound = true;\n                    break;\n                }\n            }\n        }\n        if (this.tiles[x][y-1] !== 1) {\n            let child = new PolyTreeNode({position: [x, y-1]});\n            if(!visitedNodes.includes(child)) {\n                queue.push(child);\n                visitedNodes.push(child);\n                currentNode.addChild(child);\n                child.assignParent(currentNode);\n                if((x) === cakemanX && (y-1) === cakemanY) {\n                    isFound = true;\n                    break;\n                }\n            }\n        }\n    }\n    //console.log(queue);\n    // need to iterate from back\n    // let ghostNode = visitedNodes[visitedNodes.length-1];\n    // let backToGhost = [ghostNode];\n    // let node = ghostNode.parent;\n\n    // while(node.parent !== this.ghostNode) {\n    //     backToGhost.push(node);\n    //     node = node.parent;\n    // }\n    // let nextMoveNode = node;\n    // return nextMoveNode.x;\n}\n\nTileMap.prototype.gameOverScreen = function(ctx, cakeman) {\n    // ctx.clearRect(180, 275, 110, 50);\n    ctx.font = '20px Comic Sans MS';\n    ctx.fillStyle = 'white';\n    ctx.fillText('Game Over', 185, 296);\n    ctx.fillText(`Score: ${cakeman.score}`, 196, 320);\n    // return true;\n}\n\nTileMap.prototype.winScreen = function(ctx, cakeman) {\n    // ctx.clearRect(180, 275, 110, 50);\n    ctx.font = '20px Comic Sans MS';\n    ctx.fillStyle = 'white';\n    ctx.fillText('You win!', 185, 296);\n    ctx.fillText(`Score: ${cakeman.score}`, 196, 320);\n    // return true;\n}\n\n\nmodule.exports = TileMap;\n\n","const MovingDirection = require(\"./movingDirections.js\");\n\nfunction Cakeman(options) { \n    this.x = options.position[0];\n    this.y = options.position[1];\n    this.tileSize = options.size;\n    this.velocity = 2;\n    this.tileMap = options.tileMap;\n\n    this.currentMovingDirection = null;\n    this.requestedMovingDirection = null;\n\n    this.animateTimer = null;\n    this.animateDefault = 10;\n\n    this.rotation = {\n        right: 0,\n        down: 1,\n        left: 2,\n        up: 3\n    }\n    this.cakemanRotation = this.rotation.right;\n    this.dotsLeft = 0\n    this.hasMoved = false;\n\n    this.score = 0;\n    this.timeLeft = 120;\n\n    document.addEventListener(\"keydown\", this.keydown.bind(this));\n    \n    this.loadCakemanImages();\n}\n\nCakeman.prototype.draw = function(ctx) {\n    this.move();\n    this.animate();\n    this.removeDot();\n    // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations\n    let size = this.tileSize / 2;\n    ctx.save();\n    ctx.translate(this.x + size, this.y + size);\n    ctx.rotate((this.cakemanRotation * 90 * Math.PI) / 180);\n    ctx.drawImage(\n        this.cakemanImages[this.cakemanImageIndex],\n        -size,\n        -size,\n        this.tileSize,\n        this.tileSize\n    );\n    ctx.restore();\n\n    // ctx.drawImage(\n    //     this.cakemanImages[this.cakemanImageIndex],\n    //     this.x,\n    //     this.y,\n    //     this.tileSize,\n    //     this.tileSize\n    // )\n};\n\nCakeman.prototype.timer = function timer() {\n    let countdown = setInterval((ele) => {\n        if(this.timeLeft < 0) clearInterval(countdown);\n            this.timeLeft -=1;\n        }, 1000\n    )\n}\n\nCakeman.prototype.move = function(){\n    if(this.currentMovingDirection !== this.requestedMovingDirection) {\n        if(Number.isInteger(this.x/this.tileSize) && Number.isInteger(this.y/this.tileSize)) {\n            if(!this.tileMap.didCollidedWithEnv(\n                this.x,\n                this.y,\n                this.requestedMovingDirection\n            )) this.currentMovingDirection = this.requestedMovingDirection;\n        }\n    }\n\n    if(this.tileMap.didCollidedWithEnv(this.x, this.y, this.currentMovingDirection)) {\n        this.animateTimer = null;\n        this.cakemanImageIndex = 0;\n        return;\n    } else if(this.currentMovingDirection && !this.animateTimer) {\n        this.animateTimer = this.animateDefault;\n    }\n    \n    switch(this.currentMovingDirection) {\n        case MovingDirection.up:\n        this.y -= this.velocity;\n        this.cakemanRotation = this.rotation.up;\n        break;\n        \n        case MovingDirection.down:\n        this.y += this.velocity;\n        this.cakemanRotation = this.rotation.down;\n        break; \n        \n        case MovingDirection.left:\n        this.x -= this.velocity;\n        if(this.x < 12) this.x = 23 * this.tileMap.tiles[0].length;\n        this.cakemanRotation = this.rotation.left;\n        break; \n\n        case MovingDirection.right:\n        this.x += this.velocity;\n        if(this.x >= this.tileMap.tiles[0].length * 23) this.x = 0;\n        this.cakemanRotation = this.rotation.right;\n        break; \n    }\n};\n\nCakeman.prototype.loadCakemanImages = function() {\n    const cakemanImg1 = new Image();\n    cakemanImg1.src = \"../images/cakemanClosed.png\";\n\n    const cakemanImg2 = new Image();\n    cakemanImg2.src = \"../images/cakemanHalfOpen.png\";\n\n    const cakemanImg3 = new Image();\n    cakemanImg3.src = \"../images/cakemanFullOpen.png\";\n\n    const cakemanImg4 = new Image();\n    cakemanImg4.src = \"../images/cakemanHalfOpen.png\";\n\n    this.cakemanImages = [\n        cakemanImg1,\n        cakemanImg2,\n        cakemanImg3,\n        cakemanImg4\n    ];\n\n    this.cakemanImageIndex = 0;\n};\n\nCakeman.prototype.keydown = function (event) {\n    const arr = [38, 40, 37, 39];\n\n    // if(event.keyCode === 32) this.timer();\n\n    if(arr.includes(event.keyCode)) {\n        this.hasMoved = true;\n        this.timer();\n    }\n\n    // up key\n    if(event.keyCode === 38) {\n        if(this.currentMovingDirection === MovingDirection.down) {\n            this.currentMovingDirection = MovingDirection.up;\n        }\n        this.requestedMovingDirection = MovingDirection.up;\n    }\n    // down\n    if(event.keyCode === 40) {\n        if(this.currentMovingDirection === MovingDirection.up) {\n            this.currentMovingDirection = MovingDirection.down;\n        }\n        this.requestedMovingDirection = MovingDirection.down;\n    }\n    // 37 left\n    if(event.keyCode === 37) {\n        if(this.currentMovingDirection === MovingDirection.right) {\n            this.currentMovingDirection = MovingDirection.left;\n        }\n        this.requestedMovingDirection = MovingDirection.left;\n    }\n    // 39 right\n    if(event.keyCode === 39) {\n        if(this.currentMovingDirection === MovingDirection.left) {\n            this.currentMovingDirection = MovingDirection.right;\n        }\n        this.requestedMovingDirection = MovingDirection.right;\n    }\n};\n\nCakeman.prototype.animate = function animate() {\n    if(!this.animateTimer) {\n        return;\n    }\n    this.animateTimer -=1;\n    if(this.animateTimer === 0) {\n        this.animateTimer = this.animateDefault;\n        this.cakemanImageIndex += 1;\n        if(this.cakemanImageIndex === this.cakemanImages.length) {\n            this.cakemanImageIndex = 0;\n        }\n    }\n};\n\nCakeman.prototype.removeDot = function removeDot() {\n    if(this.tileMap.removeDot(this.x, this.y)) {\n        this.score += 1;\n    }\n}\n\nmodule.exports = Cakeman;\n\n\n","const TileMap = require(\"./TileMap\");\nconst Cakeman = require(\"./cakeman.js\");\n\nfunction Game(canvas) {\n    this.canvas = canvas;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.tileSize = 24;\n    this.velocity = 2;\n    // this.tileMap = new TileMap(this.tileSize);\n    // this.cakeman = this.tileMap.getCakeman();\n    // this.ghost = this.tileMap.getGhost();\n    // this.blueGhost = this.tileMap.getGhost();\n    // this.purpleGhost = this.tileMap.getGhost();\n    // this.pinkGhost = this.tileMap.getGhost(); \n\n    // this.setCanvasSize();\n};\n\n\nGame.prototype.setCanvasSize = function setCanvasSize() {\n    this.tileMap.setCanvas(this.canvas);\n}\n\nGame.prototype.start = function() {\n    this.tileMap = new TileMap(this.tileSize);\n    this.cakeman = this.tileMap.getCakeman();\n    this.ghost = this.tileMap.getGhost();\n    this.blueGhost = this.tileMap.getGhost();\n    this.purpleGhost = this.tileMap.getGhost();\n    this.pinkGhost = this.tileMap.getGhost();\n    this.setCanvasSize(); \n\n    this.myInterval = setInterval(this.gameIter.bind(this), 1000/60);\n    // this.cakeman.timer();\n    // setInterval(this.gameIter.bind(this), 1000/60);\n}\n\nGame.prototype.stop = function() {\n    clearInterval(this.myInterval);\n}\n\nGame.prototype.gameIter = function() {\n    // console.log(`cakeman.x: ${this.cakeman.x}, ${this.cakeman.y} ghost x: ${this.ghost.x}, ${this.ghost.y}`);\n    // console.log(`ghost.moving direction: ${this.ghost.movingDirection}`);\n    if(!this.isLost()) {\n\n        this.tileMap.draw(this.ctx, this.cakeman);\n        this.cakeman.draw(this.ctx);\n        this.ghost.draw(this.ctx, this.pause(), this.cakeman);\n        this.blueGhost.draw(this.ctx, this.pause(), this.cakeman);\n        this.purpleGhost.draw(this.ctx, this.pause(), this.cakeman);\n        this.pinkGhost.draw(this.ctx, this.pause(), this.cakeman);\n    }\n    // else this.start();\n};\n\nGame.prototype.pause = function pause() {\n    return !this.cakeman.hasMoved;\n}\n\nGame.prototype.isLost = function isLost() {\n    // 2d Detection Collision on mozilla\n    // https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection\n    \n    if(\n    (this.cakeman.x < this.ghost.x + 16 &&\n    this.cakeman.x + 16 > this.ghost.x &&\n    this.cakeman.y < this.ghost.y + 16 &&\n    16 + this.cakeman.y > this.ghost.y) ||\n\n    (this.cakeman.x < this.blueGhost.x + 16 &&\n    this.cakeman.x + 16 > this.blueGhost.x &&\n    this.cakeman.y < this.blueGhost.y + 16 &&\n    16 + this.cakeman.y > this.blueGhost.y)  ||\n    \n    (this.cakeman.x < this.purpleGhost.x + 16 &&\n    this.cakeman.x + 16 > this.purpleGhost.x &&\n    this.cakeman.y < this.purpleGhost.y + 16 &&\n    16 + this.cakeman.y > this.purpleGhost.y)  ||\n\n    (this.cakeman.x < this.pinkGhost.x + 16 &&\n    this.cakeman.x + 16 > this.pinkGhost.x &&\n    this.cakeman.y < this.pinkGhost.y + 16 &&\n    16 + this.cakeman.y > this.pinkGhost.y)  ||\n\n    this.cakeman.timeLeft <= -1\n\n    ) {\n        this.tileMap.gameOverScreen(this.ctx, this.cakeman);\n        // this.stop();\n        // this.start();\n        return true;\n    }\n    return false;\n}\n\n// Game.prototype.isWin = function isWin() {\n//     let remainingDots = this.tileMap.tiles.flat().filter(v => v === 0).length;\n//     if(remainingDots === 0) {\n//         return true;     \n//     }\n//     return false;\n// }\n\nmodule.exports = Game;\n\nwindow.Game = Game;\n","const MovingDirection = require(\"./movingDirections.js\");\nconst Util = require(\"./utils.js\");\n\nfunction getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nfunction Ghost(options) { \n    this.x = options.position[0];\n    this.y = options.position[1];\n    this.tileSize = options.size;\n    this.velocity = 2;\n    this.tileMap = options.tileMap;\n    this.id = options.id\n\n    this.movingDirection = getRandomInt(1, 4); // initial random is fine\n\n    this.loadGhostImage();\n}\n\nGhost.prototype.draw = function draw(ctx, pause, cakeman) {\n    if(!pause) {\n        this.changeDirection(cakeman);\n        this.move(cakeman);\n    }\n    ctx.drawImage(\n        this.ghostImage,\n        this.x,\n        this.y,\n        this.tileSize,\n        this.tileSize\n    );\n};\n\nGhost.prototype.mockMove = function mockMove(suggestedDirection) {\n    let x = null;\n    let y = null;\n    if(!this.tileMap.didCollidedWithEnv(this.x, this.y, suggestedDirection)) {\n        if(suggestedDirection === MovingDirection.up) {\n            y = this.y - this.velocity;\n            return [this.x, y]; \n        } else if(suggestedDirection === MovingDirection.down) {\n            y = this.y + this.velocity;\n            return [this.x, y];\n        } else if(suggestedDirection === MovingDirection.right) {\n            x = this.x + this.velocity;\n            return [x, this.y];\n        } else {\n            x = this.x - this.velocity;\n            return [x, this.y];\n        }\n    }\n}\n\nGhost.prototype.move = function move(cakeman) {\n    if(!this.tileMap.didCollidedWithEnv(this.x, this.y, this.movingDirection)) {\n        switch(this.movingDirection) {\n            case MovingDirection.up:\n            this.y -= this.velocity;\n            break;\n            \n            case MovingDirection.down:\n            this.y += this.velocity;\n            break; \n            \n            case MovingDirection.left:\n            this.x -= this.velocity;\n            if(this.x < 12) this.x = 23 * this.tileMap.tiles[0].length;\n            break; \n    \n            case MovingDirection.right:\n            this.x += this.velocity;\n            if(this.x >= this.tileMap.tiles[0].length * 23) this.x=0;\n            break; \n        }\n    } \n}\n\nGhost.prototype.changeDirection = function changeDirection(cakeman) {\n    let newMoveDirection = null;\n    let newMoveDirectionName = null;\n    let possibleDirections = [];\n\n    if((this.x % this.tileSize === 0) && (this.y % this.tileSize === 0)) {\n        for(let i=1; i<5; i++) {\n            if(!this.tileMap.didCollidedWithEnv(this.x, this.y, i)){\n                let distance = Util.dist(this.mockMove(i), [cakeman.x, cakeman.y]);\n                possibleDirections.push(i);\n            }\n        }\n        \n        possibleDirections = possibleDirections.filter(item => item !== 5-this.movingDirection);\n\n        if(getRandomInt(1,2,3,4)<2) {\n            newMoveDirection = possibleDirections[Math.floor(Math.random()*possibleDirections.length)];\n        } else newMoveDirection = Util.findDirectionForGhost(this, cakeman, this.tileMap);\n        this.movingDirection = newMoveDirection;\n\n        //  TileMap BFS\n        // if((this.x % this.tileSize === 0) && (this.y % this.tileSize === 0) && this.id === 3) {\n        //     let nextmove = this.tileMap.buildTree(this, cakeman);\n        // }\n    }\n}\n\n\nGhost.prototype.loadGhostImage = function draw() {\n    this.ghostImage = new Image();\n    if(this.id === 3) {\n        this.ghostImage.src = (\"../images/redGhost.png\");\n    } else if(this.id === 4) {\n        this.ghostImage.src = (\"../images/blueGhost.png\");\n    } else if(this.id === 5) {\n        this.ghostImage.src = (\"../images/purpleGhost.png\");\n    } else if(this.id === 6) {\n        this.ghostImage.src = (\"../images/pinkGhost.png\");\n    }\n}\nmodule.exports = Ghost;","const MovingDirection = {\n    up: 4, // avoid using 0\n    down: 1,\n    left: 2,\n    right: 3,\n  };\n  \nmodule.exports = MovingDirection;","const TileMap = require(\"./TileMap\");\n\nfunction PolyTreeNode (options) {\n    this.x = options.position[0] ;\n    this.y = options.position[1] ;\n    this.parent = null;\n    this.children = [];\n}\n\nPolyTreeNode.prototype.addChild = function(child)  {\n    this.children.push(child);\n}\n\nPolyTreeNode.prototype.assignParent = function(parent) {\n    this.parent = parent;\n}\n\nmodule.exports = PolyTreeNode;","const MovingDirection = require(\"./movingDirections.js\");\n\nconst Util = {\n    inherits(childClass, parentClass) {\n        function Surrogate() {};\n        Surrogate.prototype = parentClass.prototype;\n        childClass.prototype = new Surrogate();\n        childClass.prototype.constructor = childClass;\n    },\n\n    randomVec(length) {\n        const deg = 2 * Math.PI * Math.random();\n        return Util.scale([Math.sin(deg), Math.cos(deg)], length);\n    },\n      // Scale the length of a vector by the given amount.\n    scale(vec, m) {\n        return [vec[0] * m, vec[1] * m];\n    },\n\n    dist(pos1, pos2) {\n        return Math.sqrt(\n          Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2)\n        );\n    },\n    \n    findDirectionForGhost(ghost, cakeman, tileMap) {\n        let absX = Math.abs(ghost.x - cakeman.x);\n        let absY = Math.abs(ghost.y - cakeman.y);\n        let currentD = ghost.MovingDirection;\n\n        // var item = items[Math.floor(Math.random()*items.length)];\n\n        if(absX >= absY) {\n            // should be left or right\n            if(ghost.x >= cakeman.x) {\n                // should be left\n                if(!tileMap.didCollidedWithEnv(ghost.x, ghost.y, MovingDirection.left) && MovingDirection.left !== 5 - currentD) return MovingDirection.left;\n                else if(!tileMap.didCollidedWithEnv(ghost.x, ghost.y, MovingDirection.up) && MovingDirection.up !== 5 - currentD) return MovingDirection.up;\n                else return MovingDirection.down;\n            } else {\n                // should be right\n                if(!tileMap.didCollidedWithEnv(ghost.x, ghost.y, MovingDirection.right) && MovingDirection.right !== 5 - currentD) return MovingDirection.right;\n                else if(!tileMap.didCollidedWithEnv(ghost.x, ghost.y, MovingDirection.up) && MovingDirection.up !== 5 - currentD) return MovingDirection.up;\n                else return MovingDirection.down;\n            }\n        }else {\n            // should be up or down\n            if(ghost.y >= cakeman.x) {\n                // should be up\n                if(!tileMap.didCollidedWithEnv(ghost.x, ghost.y, MovingDirection.up) && MovingDirection.up !== 5 - currentD) return MovingDirection.up;\n                else if(!tileMap.didCollidedWithEnv(ghost.x, ghost.y, MovingDirection.right) && MovingDirection.right !== 5 - currentD) return MovingDirection.right;\n                else return MovingDirection.left;\n            } else {\n                // should be down\n                if(!tileMap.didCollidedWithEnv(ghost.x, ghost.y, MovingDirection.down) && MovingDirection.down !== 5 - currentD) return MovingDirection.down;\n                else if(!tileMap.didCollidedWithEnv(ghost.x, ghost.y, MovingDirection.right) && MovingDirection.right !== 5 - currentD) return MovingDirection.right;\n                else return MovingDirection.left;\n            }\n        }            \n    }\n}\n\nmodule.exports = Util;\n\n// const MovingDirection = {\n//     up: 0, // avoid using 0\n//     down: 1,\n//     left: 2,\n//     right: 3,\n//   };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","const Game = require(\"./scripts/game.js\");\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    const canvasEl = document.getElementById('game-canvas');\n    const game = new Game(canvasEl);\n    game.start();\n    // game.stop();\n    \n});\n"],"names":["Cakeman","require","Ghost","PolyTreeNode","MovingDirection","TileMap","tileSize","this","cakeman","Image","src","wall","dot","tiles","ghostNode","prototype","setCanvas","canvas","width","length","height","draw","ctx","isLost","isWin","row","column","tile","drawWall","drawDot","drawEmpty","clearRect","font","fillStyle","fillText","score","timeLeft","size","drawImage","fillRect","getCakeman","position","tileMap","getGhost","ghost","id","didCollidedWithEnv","x","y","direction","Number","isInteger","nextColumn","nextRow","right","left","up","down","removeDot","buildTree","ghostX","Math","floor","ghostY","inputGhostNode","cakemanX","cakemanY","queue","push","isFound","visitedNodes","currentNode","shift","console","log","child","includes","addChild","assignParent","gameOverScreen","winScreen","module","exports","options","velocity","currentMovingDirection","requestedMovingDirection","animateTimer","animateDefault","rotation","cakemanRotation","dotsLeft","hasMoved","document","addEventListener","keydown","bind","loadCakemanImages","move","animate","save","translate","rotate","PI","cakemanImages","cakemanImageIndex","restore","timer","countdown","setInterval","ele","clearInterval","cakemanImg1","cakemanImg2","cakemanImg3","cakemanImg4","event","keyCode","Game","getContext","setCanvasSize","start","blueGhost","purpleGhost","pinkGhost","myInterval","gameIter","stop","pause","window","Util","getRandomInt","min","max","ceil","random","movingDirection","loadGhostImage","changeDirection","ghostImage","mockMove","suggestedDirection","newMoveDirection","possibleDirections","i","dist","filter","item","findDirectionForGhost","parent","children","inherits","childClass","parentClass","Surrogate","constructor","randomVec","deg","scale","sin","cos","vec","m","pos1","pos2","sqrt","pow","absX","abs","absY","currentD","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","canvasEl","getElementById"],"sourceRoot":""}